package sdg;
	
import lib.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.io.*;
import java.lang.System;
import java.lang.Runtime;
import java.net.*;

/**
* paints the screen from an off screen image without clearing first.
*/
class SoundingCanvas extends Canvas
  implements MouseListener, MouseMotionListener {

  Font f;
  SoundingPanel sp;
  SkewTPlot stp;
  SoundingLevel last_lev;
  int rad_ho,x_ho,y_ho;  //center of hodograph
  int ho_size;			// side of (square_ hodograph)
  double scale_ho;    // dx = scale_ho * (u in kts)
  boolean want_hodo=false;	// true if the user wants a hodograph
				// even tho we're plotting a flight
  // limits of "button" to switch between hodo and flt track
  int ho_switch_min_x,ho_switch_max_x;
  int ho_switch_min_y,ho_switch_max_y;
  Color color_ho;
  Point mouse_pt;
  Point start_mouse_pt;
  int zoom_x1,zoom_y1,zoom_x_range,zoom_y_range;
  double aspect_ratio;
  boolean dragging=false;
  boolean first_buffer_load=true;  //dont log the first load of the buffer
  // Our off-screen components for double buffering.
  Image background_image,plot_image;
  Graphics bg,pg;  //graphics for background and plot
  // values below are various positions in fractions of the plot size
  int x_lower,x_upper,x_barb,x_50,x_100,y_lower,y_upper;
  int plot_width;
  int plot_height;
  //fixed values for the max zoom-out values
  double mb10_p_lower=1050;
  double mb10_p_upper=10;
  double mb10_t_min=-82;
  double mb10_t_max=110;
  double t,td,p;       // used to pass values of temp, dewpt and pressure
  double p_lower,p_upper,t_min,t_max;
  double p_to_y;     //factor to help convert p to y
  double mlpl;        //ditto
  double t_to_x_at_p_lower;  //factor to help convert t to x
  double speed_to_x;  //factor to help convert windSpeed to an x increment
  int[] isobar = { 1050,1000,900,800,700, 600,500, 400,300, 200,  100,
		   80,60,40,20,10};
  int[] ft_alts =    {1000,5000,10000,15000,20000,25000,30000,35000,
		      40000,60000,80000,100000};
  double[] mx_rat = { .1,.2,.4,.6,1.,1.5,2.,4,5,6,7,8,10,12,14,18,22,
		      26,32,38,46 };

public SoundingCanvas(SoundingPanel sp) {
  this.sp=sp;
  addMouseListener(this);
  addMouseMotionListener(this);
  stp = new SkewTPlot(this);
  last_lev = null;
  mouse_pt = new Point(-1,-1);
  plot_width = sp.plot_width;
  plot_height = sp.plot_height;
  p_lower=SoundingDriver.default_p_lower;
  p_upper=SoundingDriver.default_p_upper;
  t_min=SoundingDriver.default_t_min;
  t_max=SoundingDriver.default_t_max;
  setSize(sp.plot_width,sp.plot_height);
  x_lower = (int)( 0.1  * plot_width);
  x_upper = (int)( 0.8  * plot_width);
  x_barb =  (int)( 0.88 * plot_width);
  x_50 =    (int)( 0.92 * plot_width);
  x_100 =   (int)( 0.96 * plot_width);
  y_lower = (int)( 0.9  * plot_height);
  y_upper = (int)( 0.05 * plot_height);
  aspect_ratio = (double)(y_lower - y_upper)/(x_upper - x_lower);
  
  //calculated variables
  speed_to_x = (x_100 - x_barb)/100.;
  set_mapping();
}

public void init() {
  f = new Font("Helvetica", Font.PLAIN, 10);
  background_image = createImage(plot_width,plot_height);
  bg = background_image.getGraphics();
  plot_image = createImage(plot_width,plot_height);
  pg = plot_image.getGraphics();
  first_buffer_load=true;
}

public void set_mapping() {
  mlpl = Math.log(p_lower);
  p_to_y = (y_lower - y_upper)/(Math.log(p_upper) - mlpl);
  t_to_x_at_p_lower = (x_upper - x_lower)/(t_max - t_min);
}

public void reset() {
  p_lower=SoundingDriver.default_p_lower;
  p_upper=SoundingDriver.default_p_upper;
  t_min=SoundingDriver.default_t_min;
  t_max=SoundingDriver.default_t_max;
  set_mapping();
  load_buffer();
  repaint();
}

public void set_10mb() {
  //sets a 10mb map
  p_lower=mb10_p_lower;
  p_upper=mb10_p_upper;
  t_min=mb10_t_min;
  t_max=mb10_t_max;
  set_mapping();
  sp.mb10_btn.indent();
  load_buffer();
  repaint();
}

public Point get_xy(double press, double t) {
  Point p = new Point(0,0);
  double dy = p_to_y*(Math.log(press) - mlpl);
  p.y = y_lower - (int)dy;
  double x_at_p_lower = t_to_x_at_p_lower*(t - t_min) + x_lower;
  p.x = (int)(x_at_p_lower + dy);
  return(p);
}

public boolean is_on_plot(Point p) {
  if(p.x < x_lower || p.x > x_upper ||
     p.y < y_upper || p.y > y_lower) {
    return false;
  }
  return true;
}

public double get_press(int y) {
  double dy = y_lower - y;
  double press = Math.exp(dy/p_to_y + mlpl);
  return(press);
}
  
public double get_t(int x, int y) {
  int dy = y_lower - y;
  int xx = x - dy;  //shift x back to its value at y_lower
  return (t_min + (xx - x_lower)/t_to_x_at_p_lower);
}
  
public void load_buffer() {
  Bat b;
  Point p,p_last;
  boolean titled=false;
  String val;
  
  //clear the screen
  bg.setColor(Color.white);
  bg.fillRect(0,0,plot_width,plot_height);
  
  //draw dry adiabats
  bg.setColor(Color.blue);
  int i_inc=1;
  if(t_max - t_min > 120) {
    i_inc = 2;
  }
  for(int i = 0;i<Bat.n_dry_adiabats;i += i_inc) {
    titled=false;
    b = Bat.dry_adiabat[i];
    p_last = get_xy(b.p[0],b.t[0]);
    for(int j = 1;j<b.n_points;j++) {
      p = get_xy(b.p[j],b.t[j]);
      bg.drawLine(p_last.x,p_last.y,p.x,p.y);
      if(p.y < .75*y_lower && ! titled) {
	val = ""+b.t_1000;
	MyUtil.drawCleanString(val,bg, f,p.x, p.y,
			       0.3,Color.blue,Color.white,1);
	titled=true;
      }
      p_last = p;
    }
  }
  
  //draw saturated adiabats
  Color brown = new Color(255,110,0);
  bg.setColor(brown);
  for(int i = 0;i<Bat.n_sat_adiabats;i++) {
    titled=false;
    b = Bat.sat_adiabat[i];
    p_last = get_xy(b.p[0],b.t[0]);
    for(int j = 1;j<b.n_points;j++) {
      p = get_xy(b.p[j],b.t[j]);
      bg.drawLine(p_last.x,p_last.y,p.x,p.y);
      if(p.y < .6*y_lower && ! titled) {
	val = ""+b.t_1000;
	MyUtil.drawCleanString(val,bg, f,p.x, p.y,
			       0.4,brown,Color.white,0.8);
	titled=true;
      }
      p_last = p;
    }
  }
  
  //clean up the bottom
  bg.setColor(Color.white);
  bg.fillRect(0,y_lower,plot_width,plot_height-y_lower);
  
  //draw mixing ratios, if we are below 200 mb
  bg.setColor(Color.gray);
  if(p_lower > 200) {
    double p_top = Math.max(p_upper,200);
    int digits=1;
    for(int i=0;i<mx_rat.length;i++) {
      double t1 = tmr(mx_rat[i],p_lower);
      p_last = get_xy(p_lower,t1);
      double t2 = tmr(mx_rat[i],p_top);
      p = get_xy(p_top,t2);
      bg.drawLine(p_last.x,p_last.y,p.x,p.y);
      if(mx_rat[i] >= 4) digits=0;
      val = MyUtil.goodRoundString(mx_rat[i],0,1.e10,"",digits);
      MyUtil.drawCleanString(val,bg, f,p_last.x,p_last.y,
			     0.3,Color.gray,Color.white,0);
      MyUtil.drawCleanString(val,bg, f,p.x-14,p.y,
			     0.5,Color.gray,Color.white,2);
    }
  }
  
  //draw isotherms
  bg.setColor(Color.red);
  int t = -140; //find a nice integral temperature
  for( ; t<= t_max; t += 10) {
    p_last = get_xy(p_lower,t);
    p      = get_xy(p_upper,t);
    bg.drawLine(p_last.x,p_last.y,p.x,p.y);
    if(t >= t_min) {
      val = ""+t;
      MyUtil.drawCleanString(val,bg, f,p_last.x, p_last.y+2,
			     0.5,Color.red,Color.white,1);
    }
    if(t <= t_max) {
      val = ""+t;
      MyUtil.drawCleanString(val,bg, f,p.x, p.y,
			     1.1,Color.red,Color.white,1);
    }
  }
  MyUtil.drawCleanString("Temperature",bg,f,
			 x_lower+(x_upper-x_lower)/2,y_lower+12,
			 0.5,Color.red,Color.white,1);
  
  //clean up the border
  bg.setColor(Color.white);
  bg.fillRect(0,0,x_lower,y_lower);
  bg.fillRect(0,0,plot_width,y_upper);
  bg.fillRect(x_upper,0,plot_width-x_upper,y_lower);
  Font bigf = new Font("Dialog", Font.ITALIC+Font.BOLD, 16);
  MyUtil.drawCleanString("NOAA - Forecast Systems Laboratory",bg, bigf,
			 plot_width/2, plot_height-5,
			 0.4,Color.blue,Color.white,0);
  bg.setColor(Color.black);
  bg.drawRect(x_lower,y_upper, x_upper - x_lower, y_lower - y_upper);
  
  
  //draw altitude lines
  bg.setColor(Color.blue);
  int extra = (x_100-x_50)/2;
  for(int i = 0;i<ft_alts.length;i++) {
    double press = Sounding.getStdPressure(ft_alts[i]);
    if(press < p_lower && press >= p_upper) {
      p = get_xy(press,t_min);
      bg.drawLine(x_lower,p.y,x_upper,p.y);
      bg.drawLine(x_barb-extra,p.y,x_100+extra,p.y);
      val = ""+(int)(ft_alts[i]/1000.);
      MyUtil.drawCleanString(val,bg, f,x_upper+(x_barb-x_upper)/2,p.y,
			     0.5,Color.blue,Color.white,0.5);
      
    }
  }
  MyUtil.drawCleanString("Press Alt.",bg, f,
			 x_upper+(x_barb-x_upper)/2, y_lower+12,
			 0.5,Color.blue,Color.white,1);
  MyUtil.drawCleanString("Kft",bg, f,x_upper+(x_barb-x_upper)/2, y_lower+22,
			 0.5,Color.blue,Color.white,1);
  
  
  //draw wind lines
  bg.setColor(Color.black);
  bg.drawLine(x_barb,y_lower,x_barb,y_upper);
  bg.drawLine(x_50,y_lower,x_50,y_upper);
  bg.drawLine(x_100,y_lower,x_100,y_upper);
  MyUtil.drawCleanString("0",bg, f,x_barb, y_lower+2,
			 0.5,Color.blue,Color.white,1);
  MyUtil.drawCleanString("50",bg, f,x_50, y_lower+2,
			 0.5,Color.blue,Color.white,1);
  MyUtil.drawCleanString("100",bg, f,x_100, y_lower+2,
			 0.5,Color.blue,Color.white,1);
  MyUtil.drawCleanString("kts",bg, f,x_50, y_lower+12,
			 0.5,Color.blue,Color.white,1);
  
  //draw isobars
  bg.setColor(Color.black);
  
  for(int i=0;i<isobar.length;i++) {
    if(isobar[i] < p_lower && isobar[i] >= p_upper) {
      p = get_xy(isobar[i],t_min);
      bg.drawLine(x_lower,p.y,x_upper,p.y);
      val = ""+isobar[i];
      MyUtil.drawCleanString(val,bg, f,x_lower-5, p.y,
			     1,Color.black,Color.white,0.5);
    }
  }
  MyUtil.drawCleanString("Pressure",bg, f,x_lower/2, (y_lower+y_upper)/2+15,
			 0.5,Color.black,Color.white,0.5);
  MyUtil.drawCleanString("(mb)",bg, f,x_lower/2, (y_lower+y_upper)/2+30,
			 0.5,Color.black,Color.white,0.5);
  
  //draw hodograph
  rad_ho = plot_width/8;
  scale_ho = rad_ho/80.;  //80 kts to the outer radius
  ho_size = 2*rad_ho + 20;
  x_ho = x_lower+ho_size/2;
  y_ho = y_upper+ho_size/2;
  ho_switch_min_x = x_lower+ho_size-50;
  ho_switch_max_x = x_lower+ho_size-4;
  ho_switch_min_y = y_upper+ho_size-20;
  ho_switch_max_y = y_upper+ho_size;
  
  bg.setColor(Color.white);
  bg.fillRect(x_lower,y_upper,ho_size,ho_size);
  bg.setColor(Color.black);
  bg.drawRect(x_lower,y_upper,ho_size,ho_size);
  bg.setColor(Color.gray);
  bg.drawLine(x_ho-rad_ho,y_ho,x_ho+rad_ho,y_ho);
  bg.drawLine(x_ho,y_ho-rad_ho,x_ho,y_ho+rad_ho);
  int r = rad_ho/4;
  int diag = (int)(0.707*r);
  // 20 kts
  bg.drawOval(x_ho-r,y_ho-r,2*r,2*r);
  MyUtil.drawCleanString("20",bg, f,x_ho-diag,y_ho+diag,
			 0.5,Color.gray,Color.white,0.5);
  //40 kts
  r += rad_ho/4;
  diag = (int)(0.707*r);
  bg.drawOval(x_ho-r,y_ho-r,2*r,2*r);
  MyUtil.drawCleanString("40",bg, f,x_ho-diag,y_ho+diag,
			 0.5,Color.gray,Color.white,0.5);
  //60 kts
  r += rad_ho/4;
  diag = (int)(0.707*r);
  bg.drawOval(x_ho-r,y_ho-r,2*r,2*r);
  MyUtil.drawCleanString("60",bg, f,x_ho-diag,y_ho+diag,
			 0.5,Color.gray,Color.white,0.5);
  //80 kts
  r += rad_ho/4;
  diag = (int)(0.707*r);
  bg.drawOval(x_ho-r,y_ho-r,2*r,2*r);
  MyUtil.drawCleanString("80",bg, f,x_ho-diag,y_ho+diag,
			 0.5,Color.gray,Color.white,0.5);
  
  Font fff = new Font("Dialog",Font.BOLD,12);
  color_ho = new Color(0,175,0);
  MyUtil.drawCleanString("wind (kts)",bg, fff,
			 x_ho - rad_ho,y_ho+rad_ho,
			 0,color_ho,Color.white,0.5);
  //it will no longer be the first load of the buffer.
  first_buffer_load=false; 
  plot_sounding();
}

public void plot_trajectory(double t, double td,double p) {
  load_buffer();
  stp.plot_trajectory(pg,t,td,p);
  String parcel_t_str = MyUtil.goodRoundString(t,-1e10,1e10,"",0);
  String parcel_p_str = MyUtil.goodRoundString(p,0,1200,"",0);
  String log_argument="parcel_t="+parcel_t_str+
                      "&parcel_p="+parcel_p_str;
  Logger logger = new Logger(sp.code_base,
			       SoundingPanel.log_file,log_argument);
}

public void plot_sounding() {
    //pull in the background
    pg.drawImage(background_image,0,0,this);
   //plot the sounding
   stp.plot_sounding(pg);
   //plot sounding titles
   stp.plot_titles(pg);
}



/**;========================================================================
;  FUNCTION TO COMPUTE THE TEMPERATURE (Celsius) OF AIR AT A GIVEN
;  PRESSURE AND WITH A GIVEN MIXING RATIO.
;  Originator:  Andrew F. Loughe  (afl@cdc.noaa.gov)
;               CIRES/NOAA
;               Boulder, CO  USA
;               This code carries no warranty or claim
;               as to its usefulness or accuracy!
;
;  A Number of the functions found in this file were converted from
;  FORTRAN code that was received from NCAR in Boulder, CO USA.
;  The original source of the equations is thought to be:
;    "Algorithms for Generating a Skew-T, Log P Diagram
;     and Computing Selected Meteorological Quantities"
;     by G.S. Stipanuk, White Sands Missle Range, Report ECOM-5515.
;*/

public double tmr(double wv,double p) {
    double x = 0.4343 * Math.log(wv * p /(622. + wv));
    double tmr = Math.pow(10,.0498646455 * x + 2.4082965 ) - 7.07475
                 + 38.9114 * Math.pow((Math.pow(10, .0915 * x) - 1.2035),2);
    return (tmr - 273.15);
}

/**
*override the standard to avoid clearing the screen
*/
public void update(Graphics g) {
  paint(g);
}

/**
* draws an off screen image from the parent onto the screen.
*/
public void paint(Graphics g) {
  g.drawImage(plot_image, 0, 0, this);
  if(dragging) {
    g.setColor(Color.red);
    g.drawRect(zoom_x1,zoom_y1,zoom_x_range,zoom_y_range);
  } else {
    //now draw the data at the mouse location, if relevant
    stp.plot_values(g,mouse_pt);
  }
}

public void mousePressed(MouseEvent e) {
  Point p = new Point(e.getX(),e.getY());
  start_mouse_pt = p;
}

public void mouseDragged(MouseEvent e) {
  int x = e.getX();
  int y = e.getY();
  mouse_pt = new Point(x,y);
  dragging=true;
  //we are zooming.  give paint a rectangle to show zoom region
  //it should have the same aspect ratio as the window
  zoom_x_range=(int)Math.abs(x-start_mouse_pt.x);
  int y_range_1=(int)(aspect_ratio*zoom_x_range);
  int y_range_2=(int)Math.abs(y-start_mouse_pt.y);
  if(y_range_2>y_range_1) {
    //y-distance determines size
    zoom_y_range=y_range_2;
    zoom_x_range=(int)(zoom_y_range/aspect_ratio);
  } else {
    //x-distance determines size
    zoom_y_range = y_range_1;
  }
  if(x > start_mouse_pt.x) {
    zoom_x1 = start_mouse_pt.x;
  } else {
    zoom_x1 = start_mouse_pt.x - zoom_x_range;
  }
  if(y > start_mouse_pt.y) {
    zoom_y1 = start_mouse_pt.y;
  } else {
    zoom_y1 = start_mouse_pt.y - zoom_y_range;
  }
  repaint();
}

public void mouseReleased(MouseEvent e) {
  String log_argument;
  Logger logger;
  int x = e.getX();
  int y = e.getY();
  //dont rescale if the zoom is too small
  if(dragging && zoom_x_range > 20) {
    mouseDragged(e);
    //get new limits
    p_upper = get_press(zoom_y1);
    p_lower = get_press(zoom_y1+zoom_y_range);
    int yy = zoom_y1+zoom_y_range;
    int xx = zoom_x1+zoom_x_range;
    double temp_t_min = get_t(zoom_x1,yy);
    t_max = get_t(xx     ,yy);
    t_min = temp_t_min;
    set_mapping();
    sp.reset_btn.unIndent();
    sp.mb10_btn.unIndent();
    load_buffer();
    repaint();
    String plo_str = MyUtil.goodRoundString(p_lower,0,1200,"",0);
    String pup_str = MyUtil.goodRoundString(p_upper,0,1200,"",0);
    String tmin_str = MyUtil.goodRoundString(t_min,-500,1200,"",0);
    String tmax_str = MyUtil.goodRoundString(t_max,-500,1200,"",0);
    log_argument="p_lower="+plo_str+"&p_upper="+pup_str+
      "&t_min="+tmin_str+"&t_max="+tmax_str;
    logger = new Logger(sp.code_base,
                               sp.log_file,log_argument);
  } else if(x > ho_switch_min_x && x < ho_switch_max_x &&
	    y > ho_switch_min_y && y < ho_switch_max_y) {
    // toggle whether we want flight track or hodograph
    want_hodo = ! want_hodo;
    boolean track= ! want_hodo;
    log_argument="track="+track;
    logger = new Logger(sp.code_base,sp.log_file,log_argument);
    load_buffer();
    repaint();
  } else {
    //no drag, so draw a trajectory of a lifted parcel from here
    t = get_t(x,y);
    td = Sounding.MISSING; //plot_trajectory will calculate
    p = get_press(y);
    if(e.isMetaDown()) {
      //ask the user for the dewpoint, temp, and pressure
      Point s_loc = getLocationOnScreen();
      new ChooseDewpoint(this,s_loc.x+x,s_loc.y+y);
    } else {
      plot_trajectory(t,td,p);
      repaint();
    }
  }
  dragging=false;
}

public void mouseMoved(MouseEvent e) {
  if(Sounding.n_soundings_to_plot > 0) {
    mouse_pt = new Point(e.getX(),e.getY());
    SoundingLevel lev = stp.get_level(mouse_pt.y);
    repaint();
  }
}

public void warn(String warning) {
  pg.setColor(Color.red);     // may need this for Explorer(?)
  pg.fillRect(0,0,plot_width,plot_height);
  Font val_font = new Font("Helvetica", Font.BOLD, 18);
  sp.reset_buttons();
  MyUtil.drawCleanString(warning,pg,val_font,plot_width/2,
                            plot_height/2,
                            0.5,Color.black,Color.white);
  warning = "Use the buttons below to display or load another";
  MyUtil.drawCleanString(warning,pg,val_font,plot_width/2,plot_height/2 + 20
                            ,0.5,Color.black,Color.white);
}

// keep the MouseListener interface happy
public void mouseExited(MouseEvent e) {}
public void mouseClicked(MouseEvent e) {}
public void mouseEntered(MouseEvent e) {}

} //end of class SoundingCanvas
