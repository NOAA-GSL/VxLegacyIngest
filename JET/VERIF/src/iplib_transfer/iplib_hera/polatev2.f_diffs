11,18c11
< C           OPTIONS ALLOW CHOOSING THE WIDTH OF THE GRID SQUARE
< C           (IPOPT(1)) TO SEARCH FOR VALID DATA, WHICH DEFAULTS TO 1
< C           (IF IPOPT(1)=-1).  ODD WIDTH SQUARES ARE CENTERED ON
< C           THE NEAREST INPUT GRID POINT; EVEN WIDTH SQUARES ARE
< C           CENTERED ON THE NEAREST FOUR INPUT GRID POINTS.
< C           SQUARES ARE SEARCHED FOR VALID DATA IN A SPIRAL PATTERN
< C           STARTING FROM THE CENTER.  NO SEARCHING IS DONE WHERE
< C           THE OUTPUT GRID IS OUTSIDE THE INPUT GRID.
---
> C           NO OPTIONS ARE ALLOWED.
49,53d41
< C 1999-04-08  IREDELL  SPLIT IJKGDS INTO TWO PIECES
< C 2001-06-18  IREDELL  INCLUDE SPIRAL SEARCH OPTION
< C 2002-01-17  IREDELL  SAVE DATA FROM LAST CALL FOR OPTIMIZATION
< C 2006-01-04  GAYNO    MINOR BUG FIX
< C 2007-10-30  IREDELL  SAVE WEIGHTS AND THREAD FOR PERFORMANCE
59,61c47
< C     IPOPT    - INTEGER (20) INTERPOLATION OPTIONS
< C                IPOPT(1) IS WIDTH OF SQUARE TO EXAMINE IN SPIRAL SEARCH
< C                (DEFAULTS TO 1 IF IPOPT(1)=-1)
---
> C     IPOPT    - INTEGER (20) INTERPOLATION OPTIONS (NO OPTIONS)
101,102c87
< C   IJKGDS0      SET UP PARAMETERS FOR IJKGDS1
< C   (IJKGDS1)    RETURN FIELD POSITION FOR A GIVEN GRID POINT
---
> C   (IJKGDS)     RETURN FIELD POSITION FOR A GIVEN GRID POINT
110,120c95,102
<       IMPLICIT NONE
<       INTEGER,INTENT(IN):: IPOPT(20),KGDSI(200),KGDSO(200),MI,MO,KM
<       INTEGER,INTENT(IN):: IBI(KM)
<       LOGICAL*1,INTENT(IN):: LI(MI,KM)
<       REAL,INTENT(IN):: UI(MI,KM),VI(MI,KM)
<       INTEGER,INTENT(INOUT):: NO
<       REAL,INTENT(INOUT):: RLAT(MO),RLON(MO),CROT(MO),SROT(MO)
<       INTEGER,INTENT(OUT):: IBO(KM)
<       LOGICAL*1,INTENT(OUT):: LO(MO,KM)
<       REAL,INTENT(OUT):: UO(MO,KM),VO(MO,KM)
<       INTEGER,INTENT(OUT):: IRET
---
> CFPP$ EXPAND(IJKGDS,MOVECT)
>       INTEGER IPOPT(20)
>       INTEGER KGDSI(200),KGDSO(200)
>       INTEGER IBI(KM),IBO(KM)
>       LOGICAL*1 LI(MI,KM),LO(MO,KM)
>       REAL UI(MI,KM),VI(MI,KM),UO(MO,KM),VO(MO,KM)
>       REAL RLAT(MO),RLON(MO)
>       REAL CROT(MO),SROT(MO)
122,126d103
<       INTEGER IJKGDSA(20)
<       REAL,PARAMETER:: FILL=-9999.
<       INTEGER MSPIRAL,N,K,NK,NV,IJKGDS1
<       INTEGER I1,J1,IXS,JXS,MX,KXS,KXT,IX,JX,NX
<       REAL DUM
128,140c105,109
<       REAL CX,SX,CM,SM,UROT,VROT
<       INTEGER,SAVE:: KGDSIX(200)=-1,KGDSOX(200)=-1,NOX=-1,IRETX=-1
<       INTEGER,ALLOCATABLE,SAVE:: NXY(:)
<       REAL,ALLOCATABLE,SAVE:: RLATX(:),RLONX(:),XPTSX(:),YPTSX(:),
<      &                        CROTX(:),SROTX(:),CXY(:),SXY(:)
< C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
< C  SET PARAMETERS
<       IRET=0
<       MSPIRAL=MAX(IPOPT(1),1)
< C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
< C  SAVE OR SKIP WEIGHT COMPUTATION
<       IF(IRET.EQ.0.AND.(KGDSO(1).LT.0.OR.
<      &    ANY(KGDSI.NE.KGDSIX).OR.ANY(KGDSO.NE.KGDSOX))) THEN
---
>       INTEGER N11(MO)
>       REAL W11(MO)
>       REAL C11(MO)
>       REAL S11(MO)
>       PARAMETER(FILL=-9999.)
143,190c112,115
<         IF(KGDSO(1).GE.0) THEN
<           CALL GDSWIZ(KGDSO, 0,MO,FILL,XPTS,YPTS,RLON,RLAT,NO,
<      &                1,CROT,SROT)
<           IF(NO.EQ.0) IRET=3
<         ENDIF
< C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
< C  LOCATE INPUT POINTS
<         CALL GDSWIZ(KGDSI,-1,NO,FILL,XPTS,YPTS,RLON,RLAT,NV,0,DUM,DUM)
<         IF(IRET.EQ.0.AND.NV.EQ.0) IRET=2
<         CALL GDSWIZ(KGDSI, 0,MI,FILL,XPTI,YPTI,RLOI,RLAI,NV,1,CROI,SROI)
< C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
< C  ALLOCATE AND SAVE GRID DATA
<         KGDSIX=KGDSI
<         KGDSOX=KGDSO
<         IF(NOX.NE.NO) THEN
<           IF(NOX.GE.0) DEALLOCATE(RLATX,RLONX,XPTSX,YPTSX,
<      &                            CROTX,SROTX,NXY,CXY,SXY)
<           ALLOCATE(RLATX(NO),RLONX(NO),XPTSX(NO),YPTSX(NO),
<      &             CROTX(NO),SROTX(NO),NXY(NO),CXY(NO),SXY(NO))
<           NOX=NO
<         ENDIF
<         IRETX=IRET
< C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
< C  COMPUTE WEIGHTS
<         IF(IRET.EQ.0) THEN
<           CALL IJKGDS0(KGDSI,IJKGDSA)
< C$OMP PARALLEL DO
< C$OMP&PRIVATE(N,CM,SM)
<           DO N=1,NO
<             RLONX(N)=RLON(N)
<             RLATX(N)=RLAT(N)
<             XPTSX(N)=XPTS(N)
<             YPTSX(N)=YPTS(N)
<             CROTX(N)=CROT(N)
<             SROTX(N)=SROT(N)
<             IF(XPTS(N).NE.FILL.AND.YPTS(N).NE.FILL) THEN
<               NXY(N)=IJKGDS1(NINT(XPTS(N)),NINT(YPTS(N)),IJKGDSA)
<               IF(NXY(N).GT.0) THEN
<                 CALL MOVECT(RLAI(NXY(N)),RLOI(NXY(N)),
<      &                      RLAT(N),RLON(N),CM,SM)
<                 CXY(N)=CM*CROI(NXY(N))+SM*SROI(NXY(N))
<                 SXY(N)=SM*CROI(NXY(N))-CM*SROI(NXY(N))
<               ENDIF
<             ELSE
<               NXY(N)=0
<             ENDIF
<           ENDDO
<         ENDIF
---
>       IRET=0
>       IF(KGDSO(1).GE.0) THEN
>         CALL GDSWIZ(KGDSO, 0,MO,FILL,XPTS,YPTS,RLON,RLAT,NO,1,CROT,SROT)
>         IF(NO.EQ.0) IRET=3
191a117
>       CALL GDSWIZ(KGDSI, 0,MI,FILL,XPTI,YPTI,RLOI,RLAI,NV,1,CROI,SROI)
193,202c119,134
< C  INTERPOLATE OVER ALL FIELDS
<       IF(IRET.EQ.0.AND.IRETX.EQ.0) THEN
<         IF(KGDSO(1).GE.0) THEN
<           NO=NOX
<           DO N=1,NO
<             RLON(N)=RLONX(N)
<             RLAT(N)=RLATX(N)
<             CROT(N)=CROTX(N)
<             SROT(N)=SROTX(N)
<           ENDDO
---
> C  LOCATE INPUT POINTS AND COMPUTE THEIR WEIGHTS AND ROTATIONS
>       CALL GDSWIZ(KGDSI,-1,NO,FILL,XPTS,YPTS,RLON,RLAT,NV,0,DUM,DUM)
>       IF(IRET.EQ.0.AND.NV.EQ.0) IRET=2
>       DO N=1,NO
>         XI=XPTS(N)
>         YI=YPTS(N)
>         IF(XI.NE.FILL.AND.YI.NE.FILL) THEN
>           I1=NINT(XI)
>           J1=NINT(YI)
>           N11(N)=IJKGDS(I1,J1,KGDSI)
>           CALL MOVECT(RLAI(N11(N)),RLOI(N11(N)),RLAT(N),RLON(N),
>      &                CM11,SM11)
>           C11(N)=CM11*CROI(N11(N))+SM11*SROI(N11(N))
>           S11(N)=SM11*CROI(N11(N))-CM11*SROI(N11(N))
>         ELSE
>           N11(N)=0
203a136,140
>       ENDDO
> C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> C  INTERPOLATE WITH OR WITHOUT BITMAPS
> CMIC$ DO ALL AUTOSCOPE
>       DO K=1,KM
205,213d141
<           XPTS(N)=XPTSX(N)
<           YPTS(N)=YPTSX(N)
<         ENDDO
< C$OMP PARALLEL DO
< C$OMP&PRIVATE(NK,K,N,I1,J1,IXS,JXS,MX,KXS,KXT,IX,JX,NX)
< C$OMP&PRIVATE(CM,SM,CX,SX,UROT,VROT)
<         DO NK=1,NO*KM
<           K=(NK-1)/NO+1
<           N=NK-NO*(K-1)
217,224c145,148
<           IF(NXY(N).GT.0) THEN
<             IF(IBI(K).EQ.0.OR.LI(NXY(N),K)) THEN
<               UROT=CXY(N)*UI(NXY(N),K)-
<      &             SXY(N)*VI(NXY(N),K)
<               VROT=SXY(N)*UI(NXY(N),K)+
<      &             CXY(N)*VI(NXY(N),K)
<               UO(N,K)=CROT(N)*UROT-SROT(N)*VROT
<               VO(N,K)=SROT(N)*UROT+CROT(N)*VROT
---
>           IF(N11(N).GT.0) THEN
>             IF(IBI(K).EQ.0.OR.LI(N11(N),K))  THEN
>               UO(N,K)=C11(N)*UI(N11(N),K)-S11(N)*VI(N11(N),K)
>               VO(N,K)=S11(N)*UI(N11(N),K)+C11(N)*VI(N11(N),K)
226,261d149
< C SPIRAL AROUND UNTIL VALID DATA IS FOUND.
<             ELSEIF(MSPIRAL.GT.1) THEN
<               I1=NINT(XPTS(N))
<               J1=NINT(YPTS(N))
<               IXS=SIGN(1.,XPTS(N)-I1)
<               JXS=SIGN(1.,YPTS(N)-J1)
<               DO MX=2,MSPIRAL**2
<                 KXS=SQRT(4*MX-2.5)
<                 KXT=MX-(KXS**2/4+1)
<                 SELECT CASE(MOD(KXS,4))
<                 CASE(1)
<                   IX=I1-IXS*(KXS/4-KXT)
<                   JX=J1-JXS*KXS/4
<                 CASE(2)
<                   IX=I1+IXS*(1+KXS/4)
<                   JX=J1-JXS*(KXS/4-KXT)
<                 CASE(3)
<                   IX=I1+IXS*(1+KXS/4-KXT)
<                   JX=J1+JXS*(1+KXS/4)
<                 CASE DEFAULT
<                   IX=I1-IXS*KXS/4
<                   JX=J1+JXS*(KXS/4-KXT)
<                 END SELECT
<                 NX=IJKGDS1(IX,JX,IJKGDSA)
<                 IF(NX.GT.0.AND.LI(NX,K)) THEN
<                   CALL MOVECT(RLAI(NX),RLOI(NX),RLAT(N),RLON(N),CM,SM)
<                   CX=CM*CROI(NX)+SM*SROI(NX)
<                   SX=SM*CROI(NX)-CM*SROI(NX)
<                   UROT=CX*UI(NX,K)-SX*VI(NX,K)
<                   VROT=SX*UI(NX,K)+CX*VI(NX,K)
<                   UO(N,K)=CROT(N)*UROT-SROT(N)*VROT
<                   VO(N,K)=SROT(N)*UROT+CROT(N)*VROT
<                   LO(N,K)=.TRUE.
<                   EXIT
<                 ENDIF
<               ENDDO
265,267c153,164
<         DO K=1,KM
<           IBO(K)=IBI(K)
<           IF(.NOT.ALL(LO(1:NO,K))) IBO(K)=1
---
>         IBO(K)=IBI(K)
>         DO N=1,NO
>           IF(LO(N,K)) THEN
>             UROT=CROT(N)*UO(N,K)-SROT(N)*VO(N,K)
>             VROT=SROT(N)*UO(N,K)+CROT(N)*VO(N,K)
>             UO(N,K)=UROT
>             VO(N,K)=VROT
>           ELSE
>             IBO(K)=1
>             UO(N,K)=0.
>             VO(N,K)=0.
>           ENDIF
269,274c166,167
<         IF(KGDSO(1).EQ.0) CALL POLFIXV(NO,MO,KM,RLAT,RLON,IBO,LO,UO,VO)
< C - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
<       ELSE
<         IF(IRET.EQ.0) IRET=IRETX
<         IF(KGDSO(1).GE.0) NO=0
<       ENDIF
---
>       ENDDO
>       IF(KGDSO(1).EQ.0) CALL POLFIXV(NO,MO,KM,RLAT,RLON,IBO,LO,UO,VO)
