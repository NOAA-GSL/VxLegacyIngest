package lib;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

/**
 * this implements 'sticky' buttons.  They optionally stay
 * pressed until the next mouse press.
 * they can also be pressed under program control.
 * Can't see a way to have this be an extension from Button,
 * and I can't see a way to register actionListeners.
 */

class MyButton extends Canvas {
  private Vector myButtonListeners=null;
  String title;
  Font f;
  FontMetrics fm;
  int height;
  int width;
  int x_text,y_text;
  boolean pressing,pressed;
  boolean toggle;
  boolean enabled=true;
  boolean control_down=false;
  boolean shift_down=false;
  Color top_color,bottom_color,text_color,background_color;
  
public MyButton(Font f, String _title, boolean _toggle) {
  title=_title;
  myButtonListeners = new Vector();
  this.f = f;
  setFont(f);
  fm = getFontMetrics(f);
  height = (int)(1.5*fm.getHeight());
  width = (int)(1.3*fm.stringWidth(title));
  y_text = height/2 + fm.getHeight()/3;
  setSize(width,height);
  pressed=false;
  pressing=false;
  toggle=_toggle;
  background_color = Color.lightGray;
  addMouseListener(new HandleMyButton());
}
  
public MyButton(Font f,String _title, boolean _toggle, int width) {
  this(f,_title,_toggle);
  this.width = width;
  setSize(width,height);
}
  
public void setBackground(Color c) {
  background_color = c;
}
  
public void setLabel(String _title) {
  title=_title;
  repaint();
}
  
public String getLabel() {
  return title;
}
  
public void reset() {
  pressed=false;
  pressing=false;
  repaint();
}

public void setEnabled(boolean enabled) {
  this.enabled = enabled;
  super.setEnabled(enabled);
  repaint();
}

public void indent() {
  //forces indentation of the button (no other actions)
  pressed=true;
  repaint();
}

public boolean controlDown() {
  return control_down;
}

public boolean shiftDown() {
  return shift_down;
}
  
public void unIndent() {
  //forces the button to pop out (no other actions)
  pressed = false;
  repaint();
}
  
public void paint(Graphics g) {
  g.setColor(background_color);
  g.fillRect(0,0,width,height);
  g.setColor(Color.black);
  //draw shadows
  if(pressing || pressed) {
    top_color = Color.black;
    bottom_color = Color.white;
  } else {
    top_color = Color.white;
    bottom_color = Color.black;
  }
  g.setColor(top_color);
  g.drawLine(2,1,width-2,1);  //top
  g.drawLine(1,height-2,1,1);   //left side
  g.setColor(bottom_color);
  g.drawLine(2,height-2,width-2,height-2);  //bottom
  g.drawLine(width-2,height-2,width-2,2); //right side
  x_text = width/2 - fm.stringWidth(title)/2;
  if(enabled) {
    text_color = Color.black;
  } else {
    text_color = Color.gray;
  }
  g.setColor(text_color);
  g.drawString(title,x_text,y_text);
}
  
public void addListener(MyButtonListener mbl) {
  if(myButtonListeners.contains(mbl)) {
    Debug.println("Error: trying to add the same MyButtonListener "+
		  "to MyButton more than once");
  } else {
    myButtonListeners.addElement(mbl);
  }
}

public void notifyListeners() {
  MyButtonListener mbl;
  for(int i=0;i<myButtonListeners.size(); i++) {
    mbl = (MyButtonListener) myButtonListeners.elementAt(i);
    mbl.myAction(this);
  }
}

private class HandleMyButton extends MouseAdapter {
public void mouseReleased(MouseEvent e) {
  if(enabled) {
    if(toggle) {
      pressed = ! pressed;
    }
    pressing=false;
    control_down = e.isControlDown();
    shift_down = e.isShiftDown();
    notifyListeners();
    repaint();
    
  }
}
public void mousePressed(MouseEvent e) {
  if(enabled) {
    pressing=true;
    repaint();
  }
}  
}
}
