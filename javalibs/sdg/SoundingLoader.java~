package sdg;
	
import lib.*;
import java.net.*;
import java.io.*;
import java.util.*;

public class SoundingLoader extends Thread {
  static SoundingLoader current_loader=null;
  SoundingPanel p;

public SoundingLoader(SoundingPanel p) {
  this.p = p;
  current_loader = this;
  this.start();
}

static public void stop_loader() {
  if(current_loader != null && current_loader.isAlive()) {
    SoundingPanel.loading_soundings=false;
    //current_loader.stop();  // DEPRECATED
    current_loader = null;
  }
}
  
public void run() {
  setPriority(Thread.MIN_PRIORITY);
    SoundingPanel.loading_soundings=true;
    p.displayArea.repaint();
    String airport = p.desired_airport;
    String line="";
  String sounding_type=null;
  String short_type="";
  float range=Sounding.MISSING;
  float bearing=Sounding.MISSING;
  int hhmm,sec_of_day,delta_secs;
  int prev_sec_of_day=0;
  String instrument=null;
    Sounding s = null;
    int sounding_index=0;
    long t1 = System.currentTimeMillis();
    boolean bad_sounding=false;
    boolean bad_airport=false;
    boolean bad_time=false;
    boolean bad_location=false;
    boolean bad_raob=false;
    boolean bad_format=false;
    float CAPE=Sounding.MISSING;
    float CIn=Sounding.MISSING;
    float Helic=Sounding.MISSING;
    float PW=Sounding.MISSING;
    InputStream fin=null;
    BufferedInputStream bfin=null;
    DataInputStream in=null;

    try {
      //get
      String code_base = ""+p.code_base;
      String access_file="";
      String enc_airport = URLEncoder.encode(airport);
      String args = "airport="+enc_airport+"&data_source="+p.data_source+
	"&startSecs="+p.startSecs+"&endSecs="+p.endSecs;
      if(p.latest) {
	// "latest" data is desired.
	int n_hrs = (p.endSecs - p.startSecs)/3600;
	args = "airport="+enc_airport+"&start=latest&n_hrs="+n_hrs+
	  "&data_source="+p.data_source;
      }
      if(p.data_source.equals("RAOB")) {
	access_file= "raobs/get_raobs.cgi?"+args;
      } else if(p.data_source.equals("PROF")) {
	access_file= "prof/get_profs.cgi?"+args;
      } else if(p.data_source.equals("ACARS")) {
	access_file="acars/get_acars.cgi?"+args;
      } else {
	access_file= "soundings/get_soundings.cgi?"+args;
      }
      URL soundingURL = new URL(p.code_base,access_file);
      URLConnection urlc = soundingURL.openConnection();
      urlc.setUseCaches(false);
      urlc.setAllowUserInteraction(true);
      Debug.println("Observations URL = "+soundingURL);
      urlc.connect();
      String key = urlc.getHeaderFieldKey(0);
      int i2=0;
      while(key != null) {
	String val = urlc.getHeaderField(key);
	Debug.println(i2+" "+key+" => "+val);
	key = urlc.getHeaderFieldKey(++i2);
      }
      fin = urlc.getInputStream();
      bfin = new BufferedInputStream(fin,4096);
      in = new DataInputStream(bfin);
      //Debug.println("Set up data input stream for obs");

      int i;
      String dum;
      int line_type=0;		// line_type indicates kind of level
      // see http://www-frd.fsl.noaa.gov/soundings/java/beta/raob_format.html
      UTCDate sounding_date=null;
      UTCDate level_date=null;
      float lat=0;
      float lon=0;
      float elev=0;
      String flag;
      int fcst_len=0;
      boolean done=false;
      boolean some_levels=false;
      while (! done) {   //loop over soundings
	i=-2;  //set up to read sounding
	Debug.println("looking for sounding...");
	sounding_date=null;
	instrument=null;
	range =Sounding.MISSING;
	while(true) {
	  line=in.readLine();
	  Debug.println(i+": "+line);
	  if(line == null) {
	    Debug.println("End of file");
	    done=true;
	    break;
	  }
	  if(line.trim().equals("")) {
	    Debug.println("blank line!");
	    if(i==-2) {
	        done=true;
	    }
	    break;
	  }
	  if(line.indexOf("ERROR") >= 0) {
	    break;
	  }
	  i++;
	  StringTokenizer items = new StringTokenizer(line," ");
	  if(i==-1) {
	    Debug.println(line);
	    sounding_type =  items.nextToken();
	    some_levels=false;
	    Debug.println("Sounding type is "+sounding_type);
	    if( sounding_type.startsWith("airport")) {
	      Debug.println("Bad airport");
	      bad_airport = true;
	      bad_sounding=true;
	      Sounding.n_soundings_to_plot=0;
	      break;
	    } else if(sounding_type.startsWith("time") ||
		      line.indexOf("for this time") != -1) {
	      Debug.println("Bad time");
	      bad_time = true;
	      bad_sounding=true;
	      Sounding.n_soundings_to_plot=0;
	      break;
	    } else if(sounding_type.startsWith("location")) {
	      Debug.println("Bad location");
	      bad_location = true;
	      bad_sounding=true;
	      Sounding.n_soundings_to_plot=0;
	      break;
	    } else if(sounding_type.indexOf("<body>") != -1) {
	      Debug.println("Strange bad sounding");
	      bad_raob=true;
	      bad_sounding=true;
	      Sounding.n_soundings_to_plot=0;
	      break;
	    } else if(sounding_type.equals("A:")) {
	      //an ACARS sounding. lotsa info on first line
	      items.nextToken(); // airport name
	      items.nextToken(); // "AC#"
	      instrument = "AC# "+items.nextToken();
	      items.nextToken(); // "U/D"
	      if(items.nextToken().equals("1")) {
		short_type="Up";
	      } else {
		short_type="Dn";
	      }
	      // read a buncha items
	      while(! items.nextToken().equals("Secs")) {}
	      sounding_date = new UTCDate(MyUtil.atoi(items.nextToken()));
	      level_date = sounding_date;
	      //save the start seconds for use
	      //when we look at times at each lev
	      prev_sec_of_day = sounding_date.getSecs();
	    } else {
	      String maybe = items.nextToken();
	      if(maybe.equalsIgnoreCase("sounding")) {
	        if(sounding_type.equals("PROF")) {
	            short_type="P";  //a profiler sounding
	        } else {
                short_type="R";
	      }
		fcst_len=0;
	      } else if(maybe.equals("analysis")) {
                short_type="A";
		if(sounding_type.equals("RUC2")) {
		  short_type="a";
		}
                fcst_len=0;
	      } else {
                short_type="F";
		if(sounding_type.equals("RUC2")) {
		  short_type="f";
		}
                fcst_len = Integer.parseInt(maybe);
	      }
	      // get distance to grid point
	      if(sounding_type.equals("RUC2") ||
		 sounding_type.equals("MAPS")) {
		   while(items.hasMoreTokens()) {
		     String it = items.nextToken();
		     if(it.equals("point")) {
		       range = MyUtil.atof(items.nextToken());
		       items.nextToken(); // 'nm'
		       items.nextToken(); // '/'
		       bearing = MyUtil.atof(items.nextToken());
		       break;
		     }
		   }
	      }
	    }
	 }  else if(i==0) {
	    flag =  items.nextToken(); //the word 'MAPS' or 'PROF' or '254'
	    Debug.println("flag = "+flag);
	    int hour = Integer.parseInt(items.nextToken());
	    int day = Integer.parseInt(items.nextToken());
	    Debug.println("Hour is "+hour+", day is "+day);
	    String month_name = items.nextToken();
	    int month = UTCDate.get_month_num(month_name);
	    int year = Integer.parseInt(items.nextToken());
	    int min = 0;
	    if(items.hasMoreTokens()) {
	      min = Integer.parseInt(items.nextToken());
	    }
	    if(sounding_date == null) {
	      //for AC soundings we already have an accurate date
	      sounding_date = new UTCDate(year,month,day,hour,min,0);
	    }
	    if(flag.equals("MAPS") || flag.equals("RUC2")) {
	      //for MAPS, read some variables out of the next line
	      line = in.readLine();
	      items = new StringTokenizer(line," ");
	      dum = items.nextToken(); //the word CAPE
	      CAPE = MyUtil.atof(items.nextToken());
	      dum = items.nextToken(); //the word CIn
	      CIn = MyUtil.atof(items.nextToken());
	      dum = items.nextToken(); //the word Helic
	      Helic = MyUtil.atof(items.nextToken());
	      dum = items.nextToken();  //the word PW
	      PW = MyUtil.atof(items.nextToken());
	      //Debug.println("CAPE = "+CAPE+", CIn = "+CIn+", Helic = "+Helic);
	    }
	  } else if (i == 1) {
	    dum = items.nextToken();  //'1'
	    dum = items.nextToken();  // don't know
	    dum = items.nextToken();  // don't know
	    lat = MyUtil.atof(items.nextToken());
	    lon = MyUtil.atof(items.nextToken());
	    elev = MyUtil.atof(items.nextToken());
	  } else if (i == 3) {   //dont read line labeled '2' at all
	    dum = items.nextToken();
	    String station = items.nextToken();
	    Debug.println("Station = "+station);
	    if(range < 0) {
	      //no range info, not a model sounding
	      s = new Sounding(short_type,fcst_len,sounding_date,lat,lon,
			       station, instrument,CAPE,CIn,Helic,PW);
	    } else {
	      s = new Sounding(short_type,fcst_len,sounding_date,lat,lon,
			       station, instrument,CAPE,CIn,Helic,PW,
			       bearing,range);
	    }
	  } else if (i >= 4) {
	    if(items.countTokens() < 7) {
	        //we have a bad line
	        Debug.println("Bad data line: "+line);
		//bad_sounding=true;
		bad_format=true;
	    } else {
	        line_type = Integer.parseInt(items.nextToken());
		// we seem to have trouble with lines of thpe
		// 7 = tropopause level and
		// 8 = max wind level, so ignore them
		if(line_type != 7 && line_type != 8) {
		  float p = MyUtil.atof(items.nextToken())/10.f;
		  //value input above is now in tenths of mb
		  float z = MyUtil.atof(items.nextToken());
		  float t = MyUtil.atof(items.nextToken());
		  float dp = MyUtil.atof(items.nextToken());
		  float wd = MyUtil.atof(items.nextToken());
		  float ws = MyUtil.atof(items.nextToken());
		  // get time, bearing, range if available
		  if(! items.hasMoreTokens()) {
		    level_date=null;
		    bearing=Sounding.MISSING;
		    range=Sounding.MISSING;
		  } else {
		    hhmm = MyUtil.atoi(items.nextToken());
		    sec_of_day = (hhmm/100)*3600 + (hhmm%100)*60;
		    delta_secs = sec_of_day - prev_sec_of_day;
		    prev_sec_of_day = sec_of_day;
		    //correct for day shift
		    if(delta_secs > 43200) {
		      delta_secs -= 86400;
		    }
		    if(delta_secs < -43200) {
		      delta_secs += 86400;
		    }
		    level_date = level_date.cloneDate();
		    level_date.addSecs(delta_secs);
		    bearing = MyUtil.atof(items.nextToken());
		    range = MyUtil.atof(items.nextToken());
		  }
		  if(z != Sounding.MISSING) {
	            if(t != Sounding.MISSING) {
		      t = t/10.f;
	            }
	            if(dp != Sounding.MISSING) {
		      dp = dp/10.f;
	            }
	            s.addLevel(p,z,t,dp,wd,ws,bearing,range,level_date);
		    some_levels=true;
		  }
		}
	    }
	  }
	}  //end of loop over lines within a sounding
	if(done || bad_sounding) {
	  Debug.println("break out due to bad sounding");
	  done=true;
	  break;  //break out of loop over soundings
	}

	if(some_levels) {
	  //generate mandatory levels
	  s.makeMands();
	  //calculate stability parameters
	  s.calcParameters();
	  
	  //add and show this sounding
	  p.add_show_sounding(s);
	}

      }  //end of loop over soundings
      Debug.println("End of loop over soundings");

      in.close();
      bfin.close();
      fin.close();
    } catch (FileNotFoundException e) {
      Debug.println("File not found: "+e);
    } catch (IOException e) {
      Debug.println("end of file for sounding:"+e);
      //displayArea.warn("Problem loading sounding");
    } catch (NoSuchElementException e) {
        bad_sounding=true;
        bad_format=true;
        Debug.println("Problem with sounding format: "+e);
    }

     if(bad_sounding) {
	    //we have a bad sounding
	    if(bad_raob) {
	        p.displayArea.warn(
		  "Requested RAOB time or location not available.");
	    } else if(bad_format) {
	        p.displayArea.warn("Problem with sounding format!");
	    } else {
	        p.displayArea.warn(line+": "+airport);
	    }
      }

    SoundingPanel.loading_soundings=false;
    p.displayArea.repaint();

  }


}
